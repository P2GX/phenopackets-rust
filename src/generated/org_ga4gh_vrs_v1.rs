// This file is @generated by prost-build.

// The serde stuff has been added manually.
// Only the most important parts of VRS are fully supported.
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct Variation {
    #[prost(oneof = "variation::Variation", tags = "1, 2, 3, 4, 5")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub variation: ::core::option::Option<variation::Variation>,
}
/// Nested message and enum types in `Variation`.
pub mod variation {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum Variation {
        #[prost(message, tag = "1")]
        Allele(super::Allele),
        #[prost(message, tag = "2")]
        Haplotype(super::Haplotype),
        #[prost(message, tag = "3")]
        CopyNumber(super::CopyNumber),
        #[prost(message, tag = "4")]
        Text(super::Text),
        #[prost(message, tag = "5")]
        VariationSet(super::VariationSet),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct MolecularVariation {
    #[prost(oneof = "molecular_variation::MolecularVariation", tags = "1, 2")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub molecular_variation: ::core::option::Option<molecular_variation::MolecularVariation>,
}
/// Nested message and enum types in `MolecularVariation`.
pub mod molecular_variation {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum MolecularVariation {
        #[prost(message, tag = "1")]
        Allele(super::Allele),
        #[prost(message, tag = "2")]
        Haplotype(super::Haplotype),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct UtilityVariation {
    #[prost(oneof = "utility_variation::UtilityVariation", tags = "1, 2")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub utility_variation: ::core::option::Option<utility_variation::UtilityVariation>,
}
/// Nested message and enum types in `UtilityVariation`.
pub mod utility_variation {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum UtilityVariation {
        #[prost(message, tag = "1")]
        Text(super::Text),
        #[prost(message, tag = "2")]
        VariationSet(super::VariationSet),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct SystemicVariation {
    #[prost(oneof = "systemic_variation::SystemicVariation", tags = "1")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub systemic_variation: ::core::option::Option<systemic_variation::SystemicVariation>,
}
/// Nested message and enum types in `SystemicVariation`.
pub mod systemic_variation {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum SystemicVariation {
        #[prost(message, tag = "1")]
        CopyNumber(super::CopyNumber),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct Allele {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(oneof = "allele::Location", tags = "2, 3, 4")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub location: ::core::option::Option<allele::Location>,
    #[prost(oneof = "allele::State", tags = "100, 5, 6, 7")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub state: ::core::option::Option<allele::State>,
}
/// Nested message and enum types in `Allele`.
pub mod allele {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum Location {
        #[prost(string, tag = "2")]
        Curie(::prost::alloc::string::String),
        #[prost(message, tag = "3")]
        ChromosomeLocation(super::ChromosomeLocation),
        #[prost(message, tag = "4")]
        SequenceLocation(super::SequenceLocation),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum State {
        #[prost(message, tag = "100")]
        SequenceState(super::SequenceState),
        #[prost(message, tag = "5")]
        LiteralSequenceExpression(super::LiteralSequenceExpression),
        #[prost(message, tag = "6")]
        DerivedSequenceExpression(super::DerivedSequenceExpression),
        #[prost(message, tag = "7")]
        RepeatedSequenceExpression(super::RepeatedSequenceExpression),
    }
}

#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct Haplotype {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<haplotype::Member>,
}
/// Nested message and enum types in `Haplotype`.
pub mod haplotype {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Message)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub struct Member {
        #[prost(oneof = "member::Value", tags = "1, 2")]
        #[cfg_attr(
            feature = "serde",
            serde(skip_serializing_if = "Option::is_none", flatten)
        )]
        pub value: ::core::option::Option<member::Value>,
    }
    /// Nested message and enum types in `Member`.
    pub mod member {
        #[cfg(feature = "serde")]
        use serde::{Deserialize, Serialize};

        #[derive(Clone, PartialEq, ::prost::Oneof)]
        #[cfg_attr(
            feature = "serde",
            derive(Serialize, Deserialize),
            serde(rename_all = "camelCase")
        )]
        pub enum Value {
            #[prost(message, tag = "1")]
            Allele(super::super::Allele),
            #[prost(string, tag = "2")]
            Curie(::prost::alloc::string::String),
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct Text {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub definition: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct VariationSet {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<variation_set::Member>,
}
/// Nested message and enum types in `VariationSet`.
pub mod variation_set {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Message)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub struct Member {
        #[prost(oneof = "member::Value", tags = "1, 2, 3, 4, 5, 6")]
        #[cfg_attr(
            feature = "serde",
            serde(skip_serializing_if = "Option::is_none", flatten)
        )]
        pub value: ::core::option::Option<member::Value>,
    }
    /// Nested message and enum types in `Member`.
    pub mod member {
        #[cfg(feature = "serde")]
        use serde::{Deserialize, Serialize};

        #[derive(Clone, PartialEq, ::prost::Oneof)]
        #[cfg_attr(
            feature = "serde",
            derive(Serialize, Deserialize),
            serde(rename_all = "camelCase")
        )]
        pub enum Value {
            #[prost(string, tag = "1")]
            Curie(::prost::alloc::string::String),
            #[prost(message, tag = "2")]
            Allele(super::super::Allele),
            #[prost(message, tag = "3")]
            Haplotype(super::super::Haplotype),
            #[prost(message, tag = "4")]
            CopyNumber(super::super::CopyNumber),
            #[prost(message, tag = "5")]
            Text(super::super::Text),
            #[prost(message, tag = "6")]
            VariationSet(super::super::VariationSet),
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct Abundance {
    #[prost(oneof = "abundance::Abundance", tags = "1")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub abundance: ::core::option::Option<abundance::Abundance>,
}
/// Nested message and enum types in `Abundance`.
pub mod abundance {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum Abundance {
        #[prost(message, tag = "1")]
        CopyNumber(super::CopyNumber),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct CopyNumber {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(oneof = "copy_number::Subject", tags = "2, 3, 4, 5, 6, 7, 8")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub subject: ::core::option::Option<copy_number::Subject>,
    #[prost(oneof = "copy_number::Copies", tags = "9, 10, 11")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub copies: ::core::option::Option<copy_number::Copies>,
}
/// Nested message and enum types in `CopyNumber`.
pub mod copy_number {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum Subject {
        #[prost(message, tag = "2")]
        Allele(super::Allele),
        #[prost(message, tag = "3")]
        Haplotype(super::Haplotype),
        #[prost(message, tag = "4")]
        Gene(super::Gene),
        #[prost(message, tag = "5")]
        LiteralSequenceExpression(super::LiteralSequenceExpression),
        #[prost(message, tag = "6")]
        DerivedSequenceExpression(super::DerivedSequenceExpression),
        #[prost(message, tag = "7")]
        RepeatedSequenceExpression(super::RepeatedSequenceExpression),
        #[prost(string, tag = "8")]
        Curie(::prost::alloc::string::String),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum Copies {
        #[prost(message, tag = "9")]
        Number(super::Number),
        #[prost(message, tag = "10")]
        IndefiniteRange(super::IndefiniteRange),
        #[prost(message, tag = "11")]
        DefiniteRange(super::DefiniteRange),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct Location {
    #[prost(oneof = "location::Location", tags = "1, 2")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub location: ::core::option::Option<location::Location>,
}
/// Nested message and enum types in `Location`.
pub mod location {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum Location {
        #[prost(message, tag = "1")]
        ChromosomeLocation(super::ChromosomeLocation),
        #[prost(message, tag = "2")]
        SequenceLocation(super::SequenceLocation),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct ChromosomeLocation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub species_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub chr: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub interval: ::core::option::Option<CytobandInterval>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct SequenceLocation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub sequence_id: ::prost::alloc::string::String,
    #[prost(oneof = "sequence_location::Interval", tags = "3, 100")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub interval: ::core::option::Option<sequence_location::Interval>,
}
/// Nested message and enum types in `SequenceLocation`.
pub mod sequence_location {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum Interval {
        #[prost(message, tag = "3")]
        SequenceInterval(super::SequenceInterval),
        #[prost(message, tag = "100")]
        SimpleInterval(super::SimpleInterval),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct SequenceInterval {
    #[prost(oneof = "sequence_interval::Start", tags = "1, 2, 3")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub start: ::core::option::Option<sequence_interval::Start>,
    #[prost(oneof = "sequence_interval::End", tags = "4, 5, 6")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub end: ::core::option::Option<sequence_interval::End>,
}
/// Nested message and enum types in `SequenceInterval`.
pub mod sequence_interval {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum Start {
        #[prost(message, tag = "1")]
        StartNumber(super::Number),
        #[prost(message, tag = "2")]
        StartIndefiniteRange(super::IndefiniteRange),
        #[prost(message, tag = "3")]
        StartDefiniteRange(super::DefiniteRange),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum End {
        #[prost(message, tag = "4")]
        EndNumber(super::Number),
        #[prost(message, tag = "5")]
        EndIndefiniteRange(super::IndefiniteRange),
        #[prost(message, tag = "6")]
        EndDefiniteRange(super::DefiniteRange),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct CytobandInterval {
    #[prost(string, tag = "1")]
    pub start: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub end: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct SequenceExpression {
    #[prost(oneof = "sequence_expression::SequenceExpression", tags = "1, 2, 3")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub sequence_expression: ::core::option::Option<sequence_expression::SequenceExpression>,
}
/// Nested message and enum types in `SequenceExpression`.
pub mod sequence_expression {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum SequenceExpression {
        #[prost(message, tag = "1")]
        LiteralSequenceExpression(super::LiteralSequenceExpression),
        #[prost(message, tag = "2")]
        DerivedSequenceExpression(super::DerivedSequenceExpression),
        #[prost(message, tag = "3")]
        RepeatedSequenceExpression(super::RepeatedSequenceExpression),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct LiteralSequenceExpression {
    #[prost(string, tag = "1")]
    pub sequence: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct DerivedSequenceExpression {
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<SequenceLocation>,
    #[prost(bool, tag = "2")]
    pub reverse_complement: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct RepeatedSequenceExpression {
    #[prost(oneof = "repeated_sequence_expression::SeqExpr", tags = "1, 2")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub seq_expr: ::core::option::Option<repeated_sequence_expression::SeqExpr>,
    #[prost(oneof = "repeated_sequence_expression::Count", tags = "3, 4, 5")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub count: ::core::option::Option<repeated_sequence_expression::Count>,
}
/// Nested message and enum types in `RepeatedSequenceExpression`.
pub mod repeated_sequence_expression {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum SeqExpr {
        #[prost(message, tag = "1")]
        LiteralSequenceExpression(super::LiteralSequenceExpression),
        #[prost(message, tag = "2")]
        DerivedSequenceExpression(super::DerivedSequenceExpression),
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum Count {
        #[prost(message, tag = "3")]
        Number(super::Number),
        #[prost(message, tag = "4")]
        IndefiniteRange(super::IndefiniteRange),
        #[prost(message, tag = "5")]
        DefiniteRange(super::DefiniteRange),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct Feature {
    #[prost(oneof = "feature::Feature", tags = "1")]
    #[cfg_attr(
        feature = "serde",
        serde(skip_serializing_if = "Option::is_none", flatten)
    )]
    pub feature: ::core::option::Option<feature::Feature>,
}
/// Nested message and enum types in `Feature`.
pub mod feature {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(
        feature = "serde",
        derive(Serialize, Deserialize),
        serde(rename_all = "camelCase")
    )]
    pub enum Feature {
        #[prost(message, tag = "1")]
        Gene(super::Gene),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct Gene {
    #[prost(string, tag = "1")]
    pub gene_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct Number {
    #[prost(uint64, tag = "1")]
    pub value: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct IndefiniteRange {
    #[prost(uint64, tag = "1")]
    pub value: u64,
    #[prost(string, tag = "2")]
    pub comparator: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct DefiniteRange {
    #[prost(uint64, tag = "1")]
    pub min: u64,
    #[prost(uint64, tag = "2")]
    pub max: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct SequenceState {
    #[prost(string, tag = "1")]
    pub sequence: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
#[cfg_attr(
    feature = "serde",
    derive(Serialize, Deserialize),
    serde(rename_all = "camelCase")
)]
pub struct SimpleInterval {
    #[prost(uint64, tag = "1")]
    pub start: u64,
    #[prost(uint64, tag = "2")]
    pub end: u64,
}
