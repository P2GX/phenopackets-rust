// This file is @generated by prost-build.
/// An anonymous phenotypic description of an individual or biosample with potential genes of interest and/or diagnoses.
///
/// This is a bundle of high-level concepts with no specifically defined relational concepts. It is expected that the
/// resources sharing the phenopackets will define and enforce their own semantics and level of requirements for included
/// fields.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Phenopacket {
    /// An identifier specific for this phenopacket.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The individual representing the focus of this packet - e.g. the proband in rare disease cases or cancer patient
    #[prost(message, optional, tag = "2")]
    pub subject:
        ::core::option::Option<crate::generated::org_phenopackets_schema_v1_core::Individual>,
    /// Phenotypic features relating to the subject of the phenopacket
    #[prost(message, repeated, tag = "3")]
    pub phenotypic_features: ::prost::alloc::vec::Vec<
        crate::generated::org_phenopackets_schema_v1_core::PhenotypicFeature,
    >,
    /// Biosample(s) derived from the patient or a collection of biosamples in isolation
    #[prost(message, repeated, tag = "4")]
    pub biosamples:
        ::prost::alloc::vec::Vec<crate::generated::org_phenopackets_schema_v1_core::Biosample>,
    /// Field for gene identifiers - could be used for listing either candidate genes or causative genes. The
    /// resources using these fields should define what this represents in their context. This could be used in order to
    /// obfuscate the specific causative/candidate variant.
    #[prost(message, repeated, tag = "5")]
    pub genes: ::prost::alloc::vec::Vec<crate::generated::org_phenopackets_schema_v1_core::Gene>,
    /// Field for genetic variants - could be used for listing either candidate variants or diagnosed causative
    /// variants. The resources using these fields should define what this represents in their context.
    #[prost(message, repeated, tag = "6")]
    pub variants:
        ::prost::alloc::vec::Vec<crate::generated::org_phenopackets_schema_v1_core::Variant>,
    /// Field for disease identifiers - could be used for listing either diagnosed or suspected conditions. The
    /// resources using these fields should define what this represents in their context.
    #[prost(message, repeated, tag = "7")]
    pub diseases:
        ::prost::alloc::vec::Vec<crate::generated::org_phenopackets_schema_v1_core::Disease>,
    /// Pointer to the relevant HTS file(s) for the patient
    #[prost(message, repeated, tag = "8")]
    pub hts_files:
        ::prost::alloc::vec::Vec<crate::generated::org_phenopackets_schema_v1_core::HtsFile>,
    /// Structured definitions of the resources and ontologies used within the phenopacket. REQUIRED
    #[prost(message, optional, tag = "9")]
    pub meta_data:
        ::core::option::Option<crate::generated::org_phenopackets_schema_v1_core::MetaData>,
}
/// Phenotype, sample and pedigree data required for a genomic diagnosis.
/// Equivalent to the Genomics England InterpretationRequestRD
/// <https://github.com/genomicsengland/GelReportModels/blob/master/schemas/IDLs/org.gel.models.report.avro/5.0.0/InterpretationRequestRD.avdl>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Family {
    /// An identifier specific for this family.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The individual representing the focus of this packet - e.g. the proband in rare disease cases or cancer patient
    #[prost(message, optional, tag = "2")]
    pub proband: ::core::option::Option<Phenopacket>,
    /// Individuals related in some way to the patient. For instance, the individuals may be genetically related or may
    /// be members of a cohort. If this field is used, then  it is expected that a pedigree will be included for
    /// genetically related individuals for use cases such as genomic diagnostics. If a phenopacket is being used to
    /// describe one member of a cohort, then in general one phenopacket will be created for each of the individuals in
    /// the cohort.
    #[prost(message, repeated, tag = "3")]
    pub relatives: ::prost::alloc::vec::Vec<Phenopacket>,
    /// The pedigree defining the relations between the proband and their relatives. Pedigree.individual_id should
    /// map to the PhenoPacket.Individual.id
    #[prost(message, optional, tag = "4")]
    pub pedigree:
        ::core::option::Option<crate::generated::org_phenopackets_schema_v1_core::Pedigree>,
    /// Pointer to the relevant HTS file(s) for the family. These should be files relating to one or more of the family
    /// members e.g a multi-sample VCF
    #[prost(message, repeated, tag = "5")]
    pub hts_files:
        ::prost::alloc::vec::Vec<crate::generated::org_phenopackets_schema_v1_core::HtsFile>,
    /// Structured definitions of the resources and ontologies used within the phenopacket. REQUIRED
    #[prost(message, optional, tag = "6")]
    pub meta_data:
        ::core::option::Option<crate::generated::org_phenopackets_schema_v1_core::MetaData>,
}
/// A group of individuals related in some phenotypic or genotypic aspect.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cohort {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub members: ::prost::alloc::vec::Vec<Phenopacket>,
    /// Pointer to the relevant HTS file(s) for the cohort
    #[prost(message, repeated, tag = "4")]
    pub hts_files:
        ::prost::alloc::vec::Vec<crate::generated::org_phenopackets_schema_v1_core::HtsFile>,
    /// Structured definitions of the resources and ontologies used within the phenopacket. REQUIRED
    #[prost(message, optional, tag = "5")]
    pub meta_data:
        ::core::option::Option<crate::generated::org_phenopackets_schema_v1_core::MetaData>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Interpretation {
    /// id of the interpretation
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// status of the interpretation
    #[prost(enumeration = "interpretation::ResolutionStatus", tag = "2")]
    pub resolution_status: i32,
    /// The diagnosis made in this interpretation
    #[prost(message, repeated, tag = "5")]
    pub diagnosis: ::prost::alloc::vec::Vec<Diagnosis>,
    /// Structured definitions of the resources and ontologies used within the phenopacket. REQUIRED
    #[prost(message, optional, tag = "6")]
    pub meta_data:
        ::core::option::Option<crate::generated::org_phenopackets_schema_v1_core::MetaData>,
    /// The individual or family which this interpretation is derived from
    #[prost(oneof = "interpretation::PhenopacketOrFamily", tags = "3, 4")]
    pub phenopacket_or_family: ::core::option::Option<interpretation::PhenopacketOrFamily>,
}
/// Nested message and enum types in `Interpretation`.
pub mod interpretation {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ResolutionStatus {
        Unknown = 0,
        Solved = 1,
        Unsolved = 2,
        InProgress = 3,
    }
    impl ResolutionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Solved => "SOLVED",
                Self::Unsolved => "UNSOLVED",
                Self::InProgress => "IN_PROGRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "SOLVED" => Some(Self::Solved),
                "UNSOLVED" => Some(Self::Unsolved),
                "IN_PROGRESS" => Some(Self::InProgress),
                _ => None,
            }
        }
    }
    /// The individual or family which this interpretation is derived from
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PhenopacketOrFamily {
        #[prost(message, tag = "3")]
        Phenopacket(super::Phenopacket),
        #[prost(message, tag = "4")]
        Family(super::Family),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Diagnosis {
    /// The disease/condition assigned to the diagnosis
    #[prost(message, optional, tag = "1")]
    pub disease: ::core::option::Option<crate::generated::org_phenopackets_schema_v1_core::Disease>,
    /// genomic features containing the status of their contribution towards the diagnosis
    #[prost(message, repeated, tag = "2")]
    pub genomic_interpretations: ::prost::alloc::vec::Vec<GenomicInterpretation>,
}
/// A statement about the contribution of a genomic element towards the observed phenotype. Note that this does not intend
/// to encode any knowledge or results of specific computations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenomicInterpretation {
    #[prost(enumeration = "genomic_interpretation::Status", tag = "1")]
    pub status: i32,
    #[prost(oneof = "genomic_interpretation::Call", tags = "2, 3")]
    pub call: ::core::option::Option<genomic_interpretation::Call>,
}
/// Nested message and enum types in `GenomicInterpretation`.
pub mod genomic_interpretation {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Status {
        Unknown = 0,
        Rejected = 1,
        Candidate = 2,
        Causative = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNKNOWN",
                Self::Rejected => "REJECTED",
                Self::Candidate => "CANDIDATE",
                Self::Causative => "CAUSATIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "REJECTED" => Some(Self::Rejected),
                "CANDIDATE" => Some(Self::Candidate),
                "CAUSATIVE" => Some(Self::Causative),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Call {
        #[prost(message, tag = "2")]
        Gene(crate::generated::org_phenopackets_schema_v1_core::Gene),
        #[prost(message, tag = "3")]
        Variant(crate::generated::org_phenopackets_schema_v1_core::Variant),
    }
}
