// This file is @generated by prost-build.

// Notes regarding serialization.
// A field marked as optional in Phenopacket Schema will be written only if the value is not default.
// For instance, a non-empty map, vector, and string.
// This does not, however, apply to `i32` (see `GestationalAge::days` or `VitalStatus::survival_time_in_days`),
// where the value of `0` *will* be written.
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

/// A class (aka term, concept) in an ontology.
/// FHIR mapping: CodeableConcept (<http://www.hl7.org/fhir/datatypes.html#CodeableConcept>)
///    see also Coding (<http://www.hl7.org/fhir/datatypes.html#Coding>)
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct OntologyClass {
    /// a CURIE-style identifier e.g. HP:0100024, MP:0001284, UBERON:0001690.
    /// This is the primary key for the ontology class
    /// REQUIRED!
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// class label, aka name. E.g. "Abnormality of cardiovascular system"
    #[prost(string, tag = "2")]
    pub label: ::prost::alloc::string::String,
}
/// FHIR mapping: Reference (<https://www.hl7.org/fhir/references.html>)
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct ExternalReference {
    /// e.g. ISBN, PMID:123456, DOI:...,
    /// FHIR mapping: Reference.identifier
    #[prost(string, tag = "1")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "String::is_empty"))]
    pub id: ::prost::alloc::string::String,
    /// A full or partial URL pointing to the external reference if no commonly resolvable identifier can be used in the
    /// `id` field
    /// FHIR mapping Reference.reference
    #[prost(string, tag = "2")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "String::is_empty"))]
    pub reference: ::prost::alloc::string::String,
    /// Human readable title or display string for the reference
    /// FHIR mapping: Reference.display
    #[prost(string, tag = "3")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "String::is_empty"))]
    pub description: ::prost::alloc::string::String,
}
/// FHIR mapping: Condition.evidence (<https://www.hl7.org/fhir/condition-definitions.html#Condition.evidence>)
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct Evidence {
    /// The encoded evidence type using, for example the Evidence & Conclusion Ontology (ECO - <http://purl.obolibrary.org/obo/eco.owl>)
    /// FHIR mapping: Condition.evidence.code
    #[prost(message, optional, tag = "1")]
    pub evidence_code: ::core::option::Option<OntologyClass>,
    /// FHIR mapping: Condition.evidence.detail
    #[prost(message, optional, tag = "2")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub reference: ::core::option::Option<ExternalReference>,
}
/// A clinical procedure performed on a subject. By preference a single concept to indicate both the procedure and the
/// body site should be used. In cases where this is not possible, the body site should be indicated using a separate
/// ontology class.
/// e.g.
/// {"code":{"NCIT:C51585": "Biopsy of Soft Palate"}}
/// {"code":{"NCIT:C28743": "Punch Biopsy"}, "body_site":{"UBERON:0003403": "skin of forearm"}} - a punch biopsy of the skin from the forearm
/// FHIR mapping: Procedure (<https://www.hl7.org/fhir/procedure.html>)
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct Procedure {
    /// FHIR mapping: Procedure.code
    #[prost(message, optional, tag = "1")]
    pub code: ::core::option::Option<OntologyClass>,
    /// FHIR mapping: Procedure.bodySite
    #[prost(message, optional, tag = "2")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub body_site: ::core::option::Option<OntologyClass>,
    /// When the procedure was performed.
    #[prost(message, optional, tag = "3")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub performed: ::core::option::Option<TimeElement>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct GestationalAge {
    #[prost(int32, tag = "1")]
    pub weeks: i32,
    // Note: It is impossible to not provide `days` to create `GestationalAge`.
    // This will lead to issues if the field is unknown.
    #[prost(int32, tag = "2")]
    pub days: i32,
}

/// See <http://build.fhir.org/datatypes> and <http://build.fhir.org/condition-definitions.html#Condition.onset_x_>
/// In FHIR this is represented as a UCUM measurement - <http://unitsofmeasure.org/trac/>
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct Age {
    /// The :ref:`ISO 8601<metadata_date_time>` age of this object as ISO8601
    /// duration or time intervals. e.g. P40Y10M05D)
    #[prost(string, tag = "1")]
    pub iso8601duration: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct AgeRange {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<Age>,
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<Age>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeInterval {
    #[prost(message, optional, tag = "1")]
    pub start: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeElement {
    #[prost(oneof = "time_element::Element", tags = "6, 1, 2, 3, 4, 5")]
    pub element: ::core::option::Option<time_element::Element>,
}
/// Nested message and enum types in `TimeElement`.
pub mod time_element {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Element {
        #[prost(message, tag = "6")]
        GestationalAge(super::GestationalAge),
        #[prost(message, tag = "1")]
        Age(super::Age),
        #[prost(message, tag = "2")]
        AgeRange(super::AgeRange),
        #[prost(message, tag = "3")]
        OntologyClass(super::OntologyClass),
        #[prost(message, tag = "4")]
        Timestamp(::prost_types::Timestamp),
        #[prost(message, tag = "5")]
        Interval(super::TimeInterval),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct File {
    /// URI for the file e.g. file://data/genomes/file1.vcf.gz or <https://opensnp.org/data/60.23andme-exome-vcf.231?1341012444>
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// A map of identifiers mapping an individual to a sample in the file. The key values must correspond to the
    /// Individual::id for the individuals in the message, the values must map to the samples in the file.
    #[prost(map = "string, string", tag = "2")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "std::collections::HashMap::is_empty"))]
    pub individual_to_file_identifiers:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Map of attributes describing the file. For example the File format or genome assembly would be defied here. For
    /// genomic data files there MUST be a 'genomeAssembly' key.
    #[prost(map = "string, string", tag = "3")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "std::collections::HashMap::is_empty"))]
    pub file_attributes:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// FHIR mapping: Observation (<https://www.hl7.org/fhir/observation.html>)
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct Measurement {
    /// Free-text description of the feature. Note this is not a acceptable place to document/describe the phenotype -
    /// the type and onset etc... fields should be used for this purpose.
    #[prost(string, tag = "1")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "String::is_empty"))]
    pub description: ::prost::alloc::string::String,
    /// An ontology class which describes the assay used to produce the measurement.
    /// For example "body temperature" (CMO:0000015) or
    /// "Platelets \[#/volume\] in Blood" (LOINC:26515-7)
    /// FHIR mapping: Observation.code
    #[prost(message, optional, tag = "2")]
    pub assay: ::core::option::Option<OntologyClass>,
    /// The time at which the measurement was made
    #[prost(message, optional, tag = "5")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub time_observed: ::core::option::Option<TimeElement>,
    /// Clinical procedure performed on the subject in order to produce the measurement.
    #[prost(message, optional, tag = "6")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub procedure: ::core::option::Option<Procedure>,
    ///       type:  LOINC: 26515-7 Platelets \[#/volume\] in Blood
    ///       value: quantity: unit: NCIT:C173275 (Count per Cubic Millimeter), value: 600,000
    #[prost(oneof = "measurement::MeasurementValue", tags = "3, 4")]
    pub measurement_value: ::core::option::Option<measurement::MeasurementValue>,
}
/// Nested message and enum types in `Measurement`.
pub mod measurement {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    ///       type:  LOINC: 26515-7 Platelets \[#/volume\] in Blood
    ///       value: quantity: unit: NCIT:C173275 (Count per Cubic Millimeter), value: 600,000
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
    pub enum MeasurementValue {
        #[prost(message, tag = "3")]
        Value(super::Value),
        #[prost(message, tag = "4")]
        ComplexValue(super::ComplexValue),
    }
}
///
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct Value {
    #[prost(oneof = "value::Value", tags = "1, 2")]
    pub value: ::core::option::Option<value::Value>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
    pub enum Value {
        #[prost(message, tag = "1")]
        Quantity(super::Quantity),
        /// for use with things such as categories 'red', 'yellow' or 'absent'/'present'
        #[prost(message, tag = "2")]
        OntologyClass(super::OntologyClass),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct ComplexValue {
    /// The quantities required to fully describe the complex value. For example the systolic and diastolic blood pressure
    /// quantities
    #[prost(message, repeated, tag = "1")]
    pub typed_quantities: ::prost::alloc::vec::Vec<TypedQuantity>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct Quantity {
    /// For instance, NCIT subhierarchy, Unit of Measure (Code C25709), <https://www.ebi.ac.uk/ols/ontologies/uo>
    #[prost(message, optional, tag = "1")]
    pub unit: ::core::option::Option<OntologyClass>,
    /// the  value of the quantity in the units  e.g. 2.0 mg
    #[prost(double, tag = "2")]
    pub value: f64,
    /// Reference range for the quantity
    /// e.g. The normal range of platelets is 150,000 to 450,000 platelets/uL.
    #[prost(message, optional, tag = "3")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub reference_range: ::core::option::Option<ReferenceRange>,
}
/// For complex measurements, such as blood pressure where more than one component quantity is required to describe the
/// measurement
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct TypedQuantity {
    /// e.g. diastolic, systolic
    #[prost(message, optional, tag = "1")]
    pub r#type: ::core::option::Option<OntologyClass>,
    /// e.g. mm Hg
    #[prost(message, optional, tag = "2")]
    pub quantity: ::core::option::Option<Quantity>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct ReferenceRange {
    #[prost(message, optional, tag = "1")]
    pub unit: ::core::option::Option<OntologyClass>,
    #[prost(double, tag = "2")]
    pub low: f64,
    #[prost(double, tag = "3")]
    pub high: f64,
}
/// An individual phenotypic feature, observed as either present or absent (negated), with possible onset, modifiers and
/// frequency
/// FHIR mapping: Condition (<https://www.hl7.org/fhir/condition.html>) or Observation (<https://www.hl7.org/fhir/observation.html>)
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct PhenotypicFeature {
    /// Free-text description of the phenotype. Note this is not a acceptable place to document/describe the phenotype -
    /// the type and onset etc... fields should be used for this purpose.
    #[prost(string, tag = "1")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "String::is_empty"))]
    pub description: ::prost::alloc::string::String,
    /// The primary ontology class which describes the phenotype. For example "HP:0001363"  "Craniosynostosis"
    /// FHIR mapping: Condition.identifier
    #[prost(message, optional, tag = "2")]
    pub r#type: ::core::option::Option<OntologyClass>,
    /// Flag to indicate whether the phenotype was observed or not. Default is 'false', in other words the phenotype was
    /// observed. Therefore it is only required in cases to indicate that the phenotype was looked for, but found to be
    /// absent.
    /// More formally, this modifier indicates the logical negation of the OntologyClass used in the 'type' field.
    /// *CAUTION* It is imperative to check this field for correct interpretation of the phenotype!
    #[prost(bool, tag = "3")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "std::ops::Not::not"))]
    pub excluded: bool,
    /// Severity of the condition e.g. subclasses of HP:0012824-Severity or SNOMED:272141005-Severities
    /// FHIR mapping: Condition.severity
    #[prost(message, optional, tag = "4")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub severity: ::core::option::Option<OntologyClass>,
    /// subclasses of HP:0012823 ! Clinical modifier apart from Severity HP:0012824 - Severity
    #[prost(message, repeated, tag = "5")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub modifiers: ::prost::alloc::vec::Vec<OntologyClass>,
    /// the values of this will come from the HPO onset hierarchy
    /// i.e. subclasses of HP:0003674
    /// FHIR mapping: Condition.onset
    #[prost(message, optional, tag = "6")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub onset: ::core::option::Option<TimeElement>,
    #[prost(message, optional, tag = "7")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub resolution: ::core::option::Option<TimeElement>,
    /// Evidences for how the phenotype was determined.
    #[prost(message, repeated, tag = "8")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub evidence: ::prost::alloc::vec::Vec<Evidence>,
}
/// A Biosample refers to a unit of biological material from which the substrate
/// molecules (e.g. genomic DNA, RNA, proteins) for molecular analyses (e.g.
/// sequencing, array hybridisation, mass-spectrometry) are extracted. Examples
/// would be a tissue biopsy, a single cell from a culture for single cell genome
/// sequencing or a protein fraction from a gradient centrifugation.
/// Several instances (e.g. technical replicates) or types of experiments (e.g.
/// genomic array as well as RNA-seq experiments) may refer to the same Biosample.
/// FHIR mapping: Specimen (<http://www.hl7.org/fhir/specimen.html>).
///
/// biosamples SAMN08666232
/// Human Cell Atlas
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct Biosample {
    /// The Biosample id This is unique in the
    /// context of the server instance.
    /// ARGO mapping specimen::submitter_specimen_id
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The id of the individual this biosample was derived from.
    /// ARGO mapping specimen::submitter_donor_id
    #[prost(string, tag = "2")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "String::is_empty"))]
    pub individual_id: ::prost::alloc::string::String,
    /// The id of the parent biosample this biosample was derived from.
    #[prost(string, tag = "3")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "String::is_empty"))]
    pub derived_from_id: ::prost::alloc::string::String,
    /// The biosample's description. This attribute contains human readable text.
    /// The "description" attributes should not contain any structured data.
    #[prost(string, tag = "4")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "String::is_empty"))]
    pub description: ::prost::alloc::string::String,
    /// UBERON class describing the tissue from which the specimen was collected.
    /// PDX-MI mapping: 'Specimen tumor tissue'
    /// FHIR mapping: Specimen.type
    /// ARGO mapping sample_registration::specimen_tissue_source
    #[prost(message, optional, tag = "5")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub sampled_tissue: ::core::option::Option<OntologyClass>,
    /// Recommended use of EFO term to describe the sample.
    /// e.g. Amplified DNA, ctDNA, Total RNA, Lung tissue, Cultured cells...
    /// ARGO mapping sample_registration::sample_type
    #[prost(message, optional, tag = "6")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub sample_type: ::core::option::Option<OntologyClass>,
    /// Phenotypic characteristics of the BioSample, for example histological findings of a biopsy.
    #[prost(message, repeated, tag = "7")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub phenotypic_features: ::prost::alloc::vec::Vec<PhenotypicFeature>,
    #[prost(message, repeated, tag = "8")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub measurements: ::prost::alloc::vec::Vec<Measurement>,
    /// NCBI taxonomic identifier (NCBITaxon) of the sample e.g. NCBITaxon:9606
    #[prost(message, optional, tag = "9")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub taxonomy: ::core::option::Option<OntologyClass>,
    /// An TimeElement describing either the age of the individual this biosample was
    /// derived from at the time of collection, or the time itself.
    /// See <http://build.fhir.org/datatypes>
    #[prost(message, optional, tag = "10")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub time_of_collection: ::core::option::Option<TimeElement>,
    /// This is the pathologist’s diagnosis and may often represent a refinement of the clinical diagnosis given in the
    /// Patient/Clinical module. Should use the same terminology as diagnosis, but represent the pathologist’s findings.
    /// Normal samples would be tagged with the term "NCIT:C38757", "Negative Finding"
    /// ARGO mapping specimen::tumour_histological_type
    #[prost(message, optional, tag = "11")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub histological_diagnosis: ::core::option::Option<OntologyClass>,
    /// Is the specimen tissue from the primary tumor, a metastasis or a recurrence?
    /// Most likely a child term of NCIT:C7062 (Neoplasm by Special Category)
    /// NCIT:C3677 (Benign Neoplasm)
    /// NCIT:C84509 (Primary Malignant Neoplasm)
    /// NCIT:C95606 (Second Primary Malignant Neoplasm)
    /// NCIT:C3261 (Metastatic Neoplasm)
    /// NCIT:C4813 (Recurrent Malignant Neoplasm)
    #[prost(message, optional, tag = "12")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub tumor_progression: ::core::option::Option<OntologyClass>,
    /// Potentially a child term of NCIT:C28076 (Disease Grade Qualifier) or equivalent
    /// See <https://www.cancer.gov/about-cancer/diagnosis-staging/prognosis/tumor-grade-fact-sheet>
    #[prost(message, optional, tag = "13")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub tumor_grade: ::core::option::Option<OntologyClass>,
    /// ARGO mapping specimen::pathological_tumour_staging_system
    /// ARGO mapping specimen::pathological_stage_group
    #[prost(message, optional, tag = "14")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub pathological_stage: ::core::option::Option<OntologyClass>,
    /// ARGO mapping specimen::pathological_t_category
    /// ARGO mapping specimen::pathological_n_category
    /// ARGO mapping specimen::pathological_m_category
    #[prost(message, repeated, tag = "15")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub pathological_tnm_finding: ::prost::alloc::vec::Vec<OntologyClass>,
    /// Clinically relevant bio markers. Most of the assays such as IHC are covered by the NCIT under the sub-hierarchy
    /// NCIT:C25294 (Laboratory Procedure).
    /// e.g. NCIT:C68748 (HER2/Neu Positive), NCIT:C131711 (Human Papillomavirus-18 Positive)
    #[prost(message, repeated, tag = "16")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub diagnostic_markers: ::prost::alloc::vec::Vec<OntologyClass>,
    /// Clinical procedure performed on the subject in order to extract the biosample.
    /// ARGO mapping specimen::specimen_anatomic_location - Procedure::body_site
    /// ARGO mapping specimen::specimen_acquisition_interval - Procedure::time_performed
    #[prost(message, optional, tag = "17")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub procedure: ::core::option::Option<Procedure>,
    /// Pointer to the relevant file(s) for the biosample. Files relating to the entire individual e.g. a germline exome/genome
    /// should be associated with the Phenopacket rather than the Biosample it was derived from.
    #[prost(message, repeated, tag = "18")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub files: ::prost::alloc::vec::Vec<File>,
    /// This element can be used to specify the status of the sample. For instance, a status may be used as a normal
    /// control, often in combination with another sample that is thought to contain a pathological finding.
    /// We recommend use of ontology terms such as:
    /// EFO:0009654 (reference sample) or EFO:0009655 (abnormal sample)
    /// ARGO mapping sample_registration::tumour_normal_designation
    #[prost(message, optional, tag = "19")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub material_sample: ::core::option::Option<OntologyClass>,
    /// Field to represent how the sample was processed.
    /// ARGO mapping specimen::specimen_processing
    #[prost(message, optional, tag = "20")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub sample_processing: ::core::option::Option<OntologyClass>,
    /// Field to represent how the sample was stored
    /// ARGO mapping specimen::specimen_storage
    #[prost(message, optional, tag = "21")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub sample_storage: ::core::option::Option<OntologyClass>,
}
/// Message to indicate a disease (diagnosis) and its recorded onset.
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct Disease {
    /// The identifier of this disease e.g. MONDO:0007043, OMIM:101600, Orphanet:710, DOID:14705 (note these are all equivalent)
    /// ARGO mapping primary_diagnosis::submitter_primary_diagnosis_id
    #[prost(message, optional, tag = "1")]
    pub term: ::core::option::Option<OntologyClass>,
    /// Flag to indicate whether the disease was observed or not. Default is 'false', in other words the disease was
    /// observed. Therefore it is only required in cases to indicate that the disease was looked for, but found to be
    /// absent.
    /// More formally, this modifier indicates the logical negation of the OntologyClass used in the 'term' field.
    /// *CAUTION* It is imperative to check this field for correct interpretation of the disease!
    #[prost(bool, tag = "2")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "std::ops::Not::not"))]
    pub excluded: bool,
    /// The onset of the disease. The values of this will come from the HPO onset hierarchy
    /// i.e. subclasses of HP:0003674
    /// FHIR mapping: Condition.onset
    /// ARGO mapping primary_diagnosis::age_at_diagnosis
    #[prost(message, optional, tag = "3")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub onset: ::core::option::Option<TimeElement>,
    #[prost(message, optional, tag = "4")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub resolution: ::core::option::Option<TimeElement>,
    /// Disease staging, the extent to which a disease has developed.
    /// For cancers, see <https://www.cancer.gov/about-cancer/diagnosis-staging/staging>
    /// Valid values include child terms of NCIT:C28108 (Disease Stage Qualifier)
    /// ARGO mapping primary_diagnosis::clinical_tumour_staging_system
    /// ARGO mapping primary_diagnosis::clinical_stage_group
    #[prost(message, repeated, tag = "5")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub disease_stage: ::prost::alloc::vec::Vec<OntologyClass>,
    /// Cancer findings in the TNM system that is relevant to the diagnosis of cancer.
    /// See <https://www.cancer.gov/about-cancer/diagnosis-staging/staging>
    /// Valid values include child terms of NCIT:C48232 (Cancer TNM Finding)
    /// ARGO mapping primary_diagnosis::clinical_t_category
    /// ARGO mapping primary_diagnosis::clinical_n_category
    /// ARGO mapping primary_diagnosis::clinical_m_category
    #[prost(message, repeated, tag = "6")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub clinical_tnm_finding: ::prost::alloc::vec::Vec<OntologyClass>,
    /// The text term used to describe the primary site of disease, as categorized by the World Health Organization's
    /// (WHO) International Classification of Diseases for Oncology (ICD-O). This categorization groups cases into general
    #[prost(message, optional, tag = "7")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub primary_site: ::core::option::Option<OntologyClass>,
    /// The term used to indicate laterality of diagnosis, if applicable. (Codelist reference: NCI CDE: 4122391)
    #[prost(message, optional, tag = "8")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub laterality: ::core::option::Option<OntologyClass>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct Interpretation {
    /// id of the interpretation
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "interpretation::ProgressStatus", tag = "2")]
    pub progress_status: i32,
    /// The diagnosis made in this interpretation
    #[prost(message, optional, tag = "3")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub diagnosis: ::core::option::Option<Diagnosis>,
    #[prost(string, tag = "4")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "String::is_empty"))]
    pub summary: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Interpretation`.
pub mod interpretation {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum ProgressStatus {
        UnknownProgress = 0,
        InProgress = 1,
        Completed = 2,
        Solved = 3,
        Unsolved = 4,
    }
    impl ProgressStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownProgress => "UNKNOWN_PROGRESS",
                Self::InProgress => "IN_PROGRESS",
                Self::Completed => "COMPLETED",
                Self::Solved => "SOLVED",
                Self::Unsolved => "UNSOLVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_PROGRESS" => Some(Self::UnknownProgress),
                "IN_PROGRESS" => Some(Self::InProgress),
                "COMPLETED" => Some(Self::Completed),
                "SOLVED" => Some(Self::Solved),
                "UNSOLVED" => Some(Self::Unsolved),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct Diagnosis {
    /// The disease/condition assigned to the diagnosis.Details about this disease may be contained in the `diseases`
    /// field in the Phenopacket.
    #[prost(message, optional, tag = "1")]
    pub disease: ::core::option::Option<OntologyClass>,
    /// genomic features containing the status of their contribution towards the diagnosis
    #[prost(message, repeated, tag = "2")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub genomic_interpretations: ::prost::alloc::vec::Vec<GenomicInterpretation>,
}
/// A statement about the contribution of a genomic element towards the observed phenotype. Note that this does not intend
/// to encode any knowledge or results of specific computations.
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct GenomicInterpretation {
    /// identifier for the subject of the interpretation. This MUST be the individual id or a biosample id of the
    /// enclosing phenopacket.
    #[prost(string, tag = "1")]
    pub subject_or_biosample_id: ::prost::alloc::string::String,
    #[prost(
        enumeration = "genomic_interpretation::InterpretationStatus",
        tag = "2"
    )]
    pub interpretation_status: i32,
    /// Gene or variant identified in subject or biosample and interpreted in relation to the disease diagnosis. In this
    /// context athe 'gene' is a proxy for an unspecified alteration in the indicated gene.
    #[prost(oneof = "genomic_interpretation::Call", tags = "3, 4")]
    pub call: ::core::option::Option<genomic_interpretation::Call>,
}
/// Nested message and enum types in `GenomicInterpretation`.
pub mod genomic_interpretation {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum InterpretationStatus {
        UnknownStatus = 0,
        Rejected = 1,
        Candidate = 2,
        Contributory = 3,
        Causative = 4,
    }
    impl InterpretationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownStatus => "UNKNOWN_STATUS",
                Self::Rejected => "REJECTED",
                Self::Candidate => "CANDIDATE",
                Self::Contributory => "CONTRIBUTORY",
                Self::Causative => "CAUSATIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_STATUS" => Some(Self::UnknownStatus),
                "REJECTED" => Some(Self::Rejected),
                "CANDIDATE" => Some(Self::Candidate),
                "CONTRIBUTORY" => Some(Self::Contributory),
                "CAUSATIVE" => Some(Self::Causative),
                _ => None,
            }
        }
    }
    /// Gene or variant identified in subject or biosample and interpreted in relation to the disease diagnosis. In this
    /// context athe 'gene' is a proxy for an unspecified alteration in the indicated gene.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
    pub enum Call {
        #[prost(message, tag = "3")]
        Gene(crate::ga4gh::vrsatile::v1::GeneDescriptor),
        #[prost(message, tag = "4")]
        VariantInterpretation(super::VariantInterpretation),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct VariantInterpretation {
    #[prost(enumeration = "AcmgPathogenicityClassification", tag = "1")]
    pub acmg_pathogenicity_classification: i32,
    #[prost(enumeration = "TherapeuticActionability", tag = "2")]
    pub therapeutic_actionability: i32,
    #[prost(message, optional, tag = "3")]
    pub variation_descriptor:
        ::core::option::Option<crate::ga4gh::vrsatile::v1::VariationDescriptor>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AcmgPathogenicityClassification {
    NotProvided = 0,
    Benign = 1,
    LikelyBenign = 2,
    UncertainSignificance = 3,
    LikelyPathogenic = 4,
    Pathogenic = 5,
}
impl AcmgPathogenicityClassification {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NotProvided => "NOT_PROVIDED",
            Self::Benign => "BENIGN",
            Self::LikelyBenign => "LIKELY_BENIGN",
            Self::UncertainSignificance => "UNCERTAIN_SIGNIFICANCE",
            Self::LikelyPathogenic => "LIKELY_PATHOGENIC",
            Self::Pathogenic => "PATHOGENIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NOT_PROVIDED" => Some(Self::NotProvided),
            "BENIGN" => Some(Self::Benign),
            "LIKELY_BENIGN" => Some(Self::LikelyBenign),
            "UNCERTAIN_SIGNIFICANCE" => Some(Self::UncertainSignificance),
            "LIKELY_PATHOGENIC" => Some(Self::LikelyPathogenic),
            "PATHOGENIC" => Some(Self::Pathogenic),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TherapeuticActionability {
    UnknownActionability = 0,
    NotActionable = 1,
    Actionable = 2,
}
impl TherapeuticActionability {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownActionability => "UNKNOWN_ACTIONABILITY",
            Self::NotActionable => "NOT_ACTIONABLE",
            Self::Actionable => "ACTIONABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_ACTIONABILITY" => Some(Self::UnknownActionability),
            "NOT_ACTIONABLE" => Some(Self::NotActionable),
            "ACTIONABLE" => Some(Self::Actionable),
            _ => None,
        }
    }
}
/// An individual (or subject) typically corresponds to an individual human or another organism.
/// FHIR mapping: Patient (<https://www.hl7.org/fhir/patient.html>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Individual {
    /// An identifier for the individual. This must be unique within the record.
    /// ARGO mapping donor::submitter_donor_id
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// An optional list of alternative identifiers for this individual. This field is provided
    /// for the convenience of users who may have multiple mappings to an individual which they need to track.
    #[prost(string, repeated, tag = "2")]
    pub alternate_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The date of birth of the individual as an ISO8601 UTC timestamp - rounded down to the closest known
    /// year/month/day/hour/minute
    /// e.g. "2018-03-01T00:00:00Z" for someone born on an unknown day in March 2018
    /// or "2018-01-01T00:00:00Z" for someone born on an unknown day in 2018
    /// or empty if unknown/ not stated.
    #[prost(message, optional, tag = "3")]
    pub date_of_birth: ::core::option::Option<::prost_types::Timestamp>,
    /// An TimeElement object describing the age of the individual at the last time of collection. The Age object allows the encoding
    /// of the age either as ISO8601 duration or time interval (preferred), or as ontology term object.
    /// See <http://build.fhir.org/datatypes>
    #[prost(message, optional, tag = "4")]
    pub time_at_last_encounter: ::core::option::Option<TimeElement>,
    /// Vital status of the individual. If not present it is assumed that the individual is alive. If present it will
    /// default to 'false' i.e. the individual was alive when the data was collected.
    /// ARGO mapping donor::vital_status
    #[prost(message, optional, tag = "5")]
    pub vital_status: ::core::option::Option<VitalStatus>,
    /// The phenotypic sex of the individual
    /// ARGO mapping sample_registration::gender (this is complicated as ARGO only have male/female/other which maps to the phenopacket Sex field)
    #[prost(enumeration = "Sex", tag = "6")]
    pub sex: i32,
    /// The karyotypic sex of the individual
    #[prost(enumeration = "KaryotypicSex", tag = "7")]
    pub karyotypic_sex: i32,
    /// Self-identified gender
    #[prost(message, optional, tag = "8")]
    pub gender: ::core::option::Option<OntologyClass>,
    /// NCBI taxonomic identifier NCBITaxon e.g. NCBITaxon:9606 or NCBITaxon:1337
    /// For resources where there may be more than one organism being studied it is advisable to indicate the taxonomic
    /// identifier of that organism, to its most specific level
    #[prost(message, optional, tag = "9")]
    pub taxonomy: ::core::option::Option<OntologyClass>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct VitalStatus {
    #[prost(enumeration = "vital_status::Status", tag = "1")]
    pub status: i32,
    #[prost(message, optional, tag = "2")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub time_of_death: ::core::option::Option<TimeElement>,
    /// ARGO mapping donor::cause_of_death
    #[prost(message, optional, tag = "3")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub cause_of_death: ::core::option::Option<OntologyClass>,
    /// ARGO mapping donor::survival_time
    #[prost(uint32, tag = "4")]
    pub survival_time_in_days: u32,
}
/// Nested message and enum types in `VitalStatus`.
pub mod vital_status {
    /// Default = false i.e. the individual is alive. MUST be true if
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Status {
        UnknownStatus = 0,
        Alive = 1,
        Deceased = 2,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownStatus => "UNKNOWN_STATUS",
                Self::Alive => "ALIVE",
                Self::Deceased => "DECEASED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_STATUS" => Some(Self::UnknownStatus),
                "ALIVE" => Some(Self::Alive),
                "DECEASED" => Some(Self::Deceased),
                _ => None,
            }
        }
    }
}
/// Sex of an individual
/// FHIR mapping: AdministrativeGender (<https://www.hl7.org/fhir/codesystem-administrative-gender.html>)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub enum Sex {
    /// Not assessed / available.
    UnknownSex = 0,
    /// Female
    Female = 1,
    /// Male
    Male = 2,
    /// It is not possible, to accurately assess the applicability of MALE/FEMALE.
    OtherSex = 3,
}
impl Sex {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownSex => "UNKNOWN_SEX",
            Self::Female => "FEMALE",
            Self::Male => "MALE",
            Self::OtherSex => "OTHER_SEX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_SEX" => Some(Self::UnknownSex),
            "FEMALE" => Some(Self::Female),
            "MALE" => Some(Self::Male),
            "OTHER_SEX" => Some(Self::OtherSex),
            _ => None,
        }
    }
}
/// Karyotypic sex of the individual
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub enum KaryotypicSex {
    UnknownKaryotype = 0,
    Xx = 1,
    Xy = 2,
    Xo = 3,
    Xxy = 4,
    Xxx = 5,
    Xxyy = 6,
    Xxxy = 7,
    Xxxx = 8,
    Xyy = 9,
    OtherKaryotype = 10,
}
impl KaryotypicSex {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownKaryotype => "UNKNOWN_KARYOTYPE",
            Self::Xx => "XX",
            Self::Xy => "XY",
            Self::Xo => "XO",
            Self::Xxy => "XXY",
            Self::Xxx => "XXX",
            Self::Xxyy => "XXYY",
            Self::Xxxy => "XXXY",
            Self::Xxxx => "XXXX",
            Self::Xyy => "XYY",
            Self::OtherKaryotype => "OTHER_KARYOTYPE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_KARYOTYPE" => Some(Self::UnknownKaryotype),
            "XX" => Some(Self::Xx),
            "XY" => Some(Self::Xy),
            "XO" => Some(Self::Xo),
            "XXY" => Some(Self::Xxy),
            "XXX" => Some(Self::Xxx),
            "XXYY" => Some(Self::Xxyy),
            "XXXY" => Some(Self::Xxxy),
            "XXXX" => Some(Self::Xxxx),
            "XYY" => Some(Self::Xyy),
            "OTHER_KARYOTYPE" => Some(Self::OtherKaryotype),
            _ => None,
        }
    }
}
/// medication, procedure, other actions taken for clinical management
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct MedicalAction {
    /// The condition or disease that this treatment was intended to address.
    /// FHIR mapping Procedure::reasonCode
    #[prost(message, optional, tag = "5")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub treatment_target: ::core::option::Option<OntologyClass>,
    /// Whether the intention of the treatment was curative, palliative,
    /// ARGO mapping treatment::treatment_intent
    #[prost(message, optional, tag = "6")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub treatment_intent: ::core::option::Option<OntologyClass>,
    /// ARGO mapping treatment::response_to_treatment
    #[prost(message, optional, tag = "7")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub response_to_treatment: ::core::option::Option<OntologyClass>,
    /// ARGO mapping treatment::adverse_events
    #[prost(message, repeated, tag = "8")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub adverse_events: ::prost::alloc::vec::Vec<OntologyClass>,
    /// ARGO mapping treatment::treatment_outcome
    #[prost(message, optional, tag = "9")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub treatment_termination_reason: ::core::option::Option<OntologyClass>,
    /// ARGO mapping treatment::treatment_type
    #[prost(oneof = "medical_action::Action", tags = "1, 2, 3, 4")]
    pub action: ::core::option::Option<medical_action::Action>,
}
/// Nested message and enum types in `MedicalAction`.
pub mod medical_action {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    /// ARGO mapping treatment::treatment_type
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
    pub enum Action {
        #[prost(message, tag = "1")]
        Procedure(super::Procedure),
        #[prost(message, tag = "2")]
        Treatment(super::Treatment),
        #[prost(message, tag = "3")]
        RadiationTherapy(super::RadiationTherapy),
        #[prost(message, tag = "4")]
        TherapeuticRegimen(super::TherapeuticRegimen),
    }
}
/// treatment with an agent, such as a drug
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct Treatment {
    /// for instance, DrugCentral, RxNorm Drugbank concept
    #[prost(message, optional, tag = "1")]
    pub agent: ::core::option::Option<OntologyClass>,
    /// For instance, NCIT subhierarchy: Route of Administration (Code C38114)
    #[prost(message, optional, tag = "2")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub route_of_administration: ::core::option::Option<OntologyClass>,
    #[prost(message, repeated, tag = "3")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Vec::is_empty"))]
    pub dose_intervals: ::prost::alloc::vec::Vec<DoseInterval>,
    #[prost(enumeration = "DrugType", tag = "4")]
    pub drug_type: i32,
    /// ARGO mapping chemotherapy::cumulative_drug_dosage
    #[prost(message, optional, tag = "5")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub cumulative_dose: ::core::option::Option<Quantity>,
}
/// e.g. 50mg/ml 3 times daily for two weeks
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct DoseInterval {
    #[prost(message, optional, tag = "1")]
    pub quantity: ::core::option::Option<Quantity>,
    #[prost(message, optional, tag = "2")]
    pub schedule_frequency: ::core::option::Option<OntologyClass>,
    #[prost(message, optional, tag = "3")]
    pub interval: ::core::option::Option<TimeInterval>,
}
/// RadiationTherapy
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct RadiationTherapy {
    /// The modality of radiation therapy (e.g., electron, photon,…). REQUIRED.
    /// ARGO mapping radiation::radiation_therapy_modality
    #[prost(message, optional, tag = "1")]
    pub modality: ::core::option::Option<OntologyClass>,
    /// The anatomical site where radiation therapy was administered. REQUIRED.
    /// ARGO mapping radiation::anatomical_site_irradiated
    #[prost(message, optional, tag = "2")]
    pub body_site: ::core::option::Option<OntologyClass>,
    /// The total dose given in units of Gray (Gy). REQUIRED.
    /// ARGO mapping radiation::radiation_therapy_dosage
    #[prost(int32, tag = "3")]
    pub dosage: i32,
    /// The total number of fractions delivered as part of treatment. REQUIRED.
    /// ARGO mapping radiation::radiation_therapy_fractions
    #[prost(int32, tag = "4")]
    pub fractions: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct TherapeuticRegimen {
    /// possibly undefined;
    #[prost(message, optional, tag = "3")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub start_time: ::core::option::Option<TimeElement>,
    /// end time can be empty which would indicate ongoing
    #[prost(message, optional, tag = "4")]
    #[cfg_attr(feature = "serde", serde(skip_serializing_if = "Option::is_none"))]
    pub end_time: ::core::option::Option<TimeElement>,
    #[prost(enumeration = "therapeutic_regimen::RegimenStatus", tag = "5")]
    pub regimen_status: i32,
    /// <https://ctep.cancer.gov/protocolDevelopment/policies_nomenclature.htm>
    #[prost(oneof = "therapeutic_regimen::Identifier", tags = "1, 2")]
    pub identifier: ::core::option::Option<therapeutic_regimen::Identifier>,
}
/// Nested message and enum types in `TherapeuticRegimen`.
pub mod therapeutic_regimen {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
    #[repr(i32)]
    pub enum RegimenStatus {
        UnknownStatus = 0,
        Started = 1,
        Completed = 2,
        Discontinued = 3,
    }
    impl RegimenStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownStatus => "UNKNOWN_STATUS",
                Self::Started => "STARTED",
                Self::Completed => "COMPLETED",
                Self::Discontinued => "DISCONTINUED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_STATUS" => Some(Self::UnknownStatus),
                "STARTED" => Some(Self::Started),
                "COMPLETED" => Some(Self::Completed),
                "DISCONTINUED" => Some(Self::Discontinued),
                _ => None,
            }
        }
    }
    /// <https://ctep.cancer.gov/protocolDevelopment/policies_nomenclature.htm>
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
    pub enum Identifier {
        #[prost(message, tag = "1")]
        ExternalReference(super::ExternalReference),
        #[prost(message, tag = "2")]
        OntologyClass(super::OntologyClass),
    }
}
/// A simplified version of ODHSI-DRUG_EXPOSURE
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
#[repr(i32)]
pub enum DrugType {
    UnknownDrugType = 0,
    Prescription = 1,
    EhrMedicationList = 2,
    AdministrationRelatedToProcedure = 3,
}
impl DrugType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownDrugType => "UNKNOWN_DRUG_TYPE",
            Self::Prescription => "PRESCRIPTION",
            Self::EhrMedicationList => "EHR_MEDICATION_LIST",
            Self::AdministrationRelatedToProcedure => "ADMINISTRATION_RELATED_TO_PROCEDURE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_DRUG_TYPE" => Some(Self::UnknownDrugType),
            "PRESCRIPTION" => Some(Self::Prescription),
            "EHR_MEDICATION_LIST" => Some(Self::EhrMedicationList),
            "ADMINISTRATION_RELATED_TO_PROCEDURE" => Some(Self::AdministrationRelatedToProcedure),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetaData {
    /// ISO8601 UTC timestamp for when this phenopacket was created in ISO "2018-03-01T00:00:00Z"
    #[prost(message, optional, tag = "1")]
    pub created: ::core::option::Option<::prost_types::Timestamp>,
    /// some kind of identifier for the contributor/ program
    /// ARGO sample_registration::program_id
    #[prost(string, tag = "2")]
    pub created_by: ::prost::alloc::string::String,
    /// information about the person/organisation/network that has submitted this phenopacket
    #[prost(string, tag = "3")]
    pub submitted_by: ::prost::alloc::string::String,
    /// a listing of the ontologies and resources referenced in the phenopacket
    #[prost(message, repeated, tag = "4")]
    pub resources: ::prost::alloc::vec::Vec<Resource>,
    /// An OPTIONAL list of Updates to the phenopacket.
    #[prost(message, repeated, tag = "5")]
    pub updates: ::prost::alloc::vec::Vec<Update>,
    /// phenopacket-schema-version used to create this phenopacket
    #[prost(string, tag = "6")]
    pub phenopacket_schema_version: ::prost::alloc::string::String,
    /// External identifiers for this message. These are considered different representation of the same record, not
    /// records which are in some other relation with the record at hand. For example this might be a PubMed reference
    /// to a study in which the individuals are reported.
    #[prost(message, repeated, tag = "7")]
    pub external_references: ::prost::alloc::vec::Vec<ExternalReference>,
}
/// Description of an external resource used for referencing an object. For example the resource may be an ontology such
/// as the HPO or SNOMED.
/// FHIR mapping: CodeSystem (<http://www.hl7.org/fhir/codesystem.html>)
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct Resource {
    /// for OBO Ontologies, the value of this string MUST always be the official
    /// OBO ID, which is always equivalent to the ID prefix in lower case.
    /// Examples: hp, go, mp, mondo
    /// Consult <http://obofoundry.org> for a complete list
    /// For other ontologies (e.g. SNOMED), use the prefix in identifiers.org
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// e.g. The Human Phenotype Ontology
    /// for OBO Ontologies, the value of this string SHOULD be the same as the title
    /// field on <http://obofoundry.org>
    /// however, this field is purely for information purposes and software
    /// should not encode any assumptions
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// For OBO ontologies, this should always be the PURL, e.g.
    /// <http://purl.obolibrary.org/obo/hp.owl,> <http://purl.obolibrary.org/obo/hp.obo>
    #[prost(string, tag = "3")]
    pub url: ::prost::alloc::string::String,
    /// for OBO ontologies, this should be the versionIRI
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
    /// The prefix used in the CURIE of an OntologyClass e.g. HP, MP, ECO
    /// For example an HPO term will have a CURIE like this - HP:0012828 which should be used in combination with
    /// the iri_prefix to form a fully-resolvable IRI
    #[prost(string, tag = "5")]
    pub namespace_prefix: ::prost::alloc::string::String,
    /// Full IRI prefix which can be used with the namespace_prefix and the OntologyClass::id to resolve to an IRI for a
    /// term. Tools such as the curie-util (<https://github.com/prefixcommons/curie-util>) can utilise this to produce
    /// fully-resolvable IRIs for an OntologyClass.
    /// e.g. Using the HPO term encoding the concept of 'Severe'
    ///     OntologyClass:
    ///         id: 'HP:0012828'
    ///         label: 'Severe'
    ///     Resource:
    ///         namespace_prefix: 'HP'
    ///         iri_prefix: '<http://purl.obolibrary.org/obo/HP_'>
    /// the term can be resolved to <http://purl.obolibrary.org/obo/HP_0012828>
    #[prost(string, tag = "6")]
    pub iri_prefix: ::prost::alloc::string::String,
}
/// Information about when an update to a record occurred, who or what made the update and any pertinent information
/// regarding the content and/or reason for the update
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Update {
    /// ISO8601 UTC timestamps at which this record was updated, in
    /// the format YYYY-MM-DDTHH:MM:SS.SSSZ e.g. 2007-12-03T10:15:30.00Z
    /// REQUIRED
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Information about the person/organisation/network that has updated the phenopacket.
    /// OPTIONAL
    #[prost(string, tag = "2")]
    pub updated_by: ::prost::alloc::string::String,
    /// Textual comment about the changes made to the content and/or reason for the update.
    /// OPTIONAL
    #[prost(string, tag = "3")]
    pub comment: ::prost::alloc::string::String,
}
/// <https://software.broadinstitute.org/gatk/documentation/article?id=11016>
#[derive(Clone, PartialEq, ::prost::Message)]
#[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
pub struct Pedigree {
    #[prost(message, repeated, tag = "1")]
    pub persons: ::prost::alloc::vec::Vec<pedigree::Person>,
}
/// Nested message and enum types in `Pedigree`.
pub mod pedigree {
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};

    #[derive(Clone, PartialEq, ::prost::Message)]
    #[cfg_attr(feature = "serde", derive(Serialize), serde(rename_all = "camelCase"))]
    pub struct Person {
        #[prost(string, tag = "1")]
        pub family_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub individual_id: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub paternal_id: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub maternal_id: ::prost::alloc::string::String,
        #[prost(enumeration = "super::Sex", tag = "5")]
        pub sex: i32,
        #[prost(enumeration = "person::AffectedStatus", tag = "6")]
        pub affected_status: i32,
    }
    /// Nested message and enum types in `Person`.
    pub mod person {
        #[cfg(feature = "serde")]
        use serde::{Deserialize, Serialize};

        #[derive(
            Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration,
        )]
        #[repr(i32)]
        pub enum AffectedStatus {
            Missing = 0,
            Unaffected = 1,
            Affected = 2,
        }
        impl AffectedStatus {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Missing => "MISSING",
                    Self::Unaffected => "UNAFFECTED",
                    Self::Affected => "AFFECTED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MISSING" => Some(Self::Missing),
                    "UNAFFECTED" => Some(Self::Unaffected),
                    "AFFECTED" => Some(Self::Affected),
                    _ => None,
                }
            }
        }
    }
}
